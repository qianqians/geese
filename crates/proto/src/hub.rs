// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::common;

//
// ClientRequestLogin
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientRequestLogin {
  pub gate_name: Option<String>,
  pub gate_host: Option<String>,
  pub conn_id: Option<String>,
  pub sdk_uuid: Option<String>,
  pub argvs: Option<Vec<u8>>,
}

impl ClientRequestLogin {
  pub fn new<F1, F2, F3, F4, F5>(gate_name: F1, gate_host: F2, conn_id: F3, sdk_uuid: F4, argvs: F5) -> ClientRequestLogin where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<Vec<u8>>> {
    ClientRequestLogin {
      gate_name: gate_name.into(),
      gate_host: gate_host.into(),
      conn_id: conn_id.into(),
      sdk_uuid: sdk_uuid.into(),
      argvs: argvs.into(),
    }
  }
}

impl TSerializable for ClientRequestLogin {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientRequestLogin> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientRequestLogin {
      gate_name: f_1,
      gate_host: f_2,
      conn_id: f_3,
      sdk_uuid: f_4,
      argvs: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_request_login");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.gate_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gate_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_host", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sdk_uuid {
      o_prot.write_field_begin(&TFieldIdentifier::new("sdk_uuid", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.argvs {
      o_prot.write_field_begin(&TFieldIdentifier::new("argvs", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientRequestReconnect
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientRequestReconnect {
  pub gate_name: Option<String>,
  pub gate_host: Option<String>,
  pub conn_id: Option<String>,
  pub account_id: Option<String>,
  pub token: Option<String>,
}

impl ClientRequestReconnect {
  pub fn new<F1, F2, F3, F4, F5>(gate_name: F1, gate_host: F2, conn_id: F3, account_id: F4, token: F5) -> ClientRequestReconnect where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    ClientRequestReconnect {
      gate_name: gate_name.into(),
      gate_host: gate_host.into(),
      conn_id: conn_id.into(),
      account_id: account_id.into(),
      token: token.into(),
    }
  }
}

impl TSerializable for ClientRequestReconnect {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientRequestReconnect> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientRequestReconnect {
      gate_name: f_1,
      gate_host: f_2,
      conn_id: f_3,
      account_id: f_4,
      token: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_request_reconnect");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.gate_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gate_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_host", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.account_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("account_id", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.token {
      o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientRequestService
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientRequestService {
  pub service_name: Option<String>,
  pub gate_name: Option<String>,
  pub gate_host: Option<String>,
  pub conn_id: Option<String>,
}

impl ClientRequestService {
  pub fn new<F1, F2, F3, F4>(service_name: F1, gate_name: F2, gate_host: F3, conn_id: F4) -> ClientRequestService where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>> {
    ClientRequestService {
      service_name: service_name.into(),
      gate_name: gate_name.into(),
      gate_host: gate_host.into(),
      conn_id: conn_id.into(),
    }
  }
}

impl TSerializable for ClientRequestService {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientRequestService> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientRequestService {
      service_name: f_1,
      gate_name: f_2,
      gate_host: f_3,
      conn_id: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_request_service");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.service_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("service_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gate_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gate_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_host", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransferMsgEnd
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TransferMsgEnd {
  pub conn_id: Option<String>,
  pub is_kick_off: Option<bool>,
}

impl TransferMsgEnd {
  pub fn new<F1, F2>(conn_id: F1, is_kick_off: F2) -> TransferMsgEnd where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    TransferMsgEnd {
      conn_id: conn_id.into(),
      is_kick_off: is_kick_off.into(),
    }
  }
}

impl TSerializable for TransferMsgEnd {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransferMsgEnd> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransferMsgEnd {
      conn_id: f_1,
      is_kick_off: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("transfer_msg_end");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_kick_off {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_kick_off", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransferEntityControl
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TransferEntityControl {
  pub entity_id: Option<String>,
  pub is_main: Option<bool>,
  pub is_reconnect: Option<bool>,
  pub gate_name: Option<String>,
  pub conn_id: Option<String>,
}

impl TransferEntityControl {
  pub fn new<F1, F2, F3, F4, F5>(entity_id: F1, is_main: F2, is_reconnect: F3, gate_name: F4, conn_id: F5) -> TransferEntityControl where F1: Into<Option<String>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    TransferEntityControl {
      entity_id: entity_id.into(),
      is_main: is_main.into(),
      is_reconnect: is_reconnect.into(),
      gate_name: gate_name.into(),
      conn_id: conn_id.into(),
    }
  }
}

impl TSerializable for TransferEntityControl {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransferEntityControl> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransferEntityControl {
      entity_id: f_1,
      is_main: f_2,
      is_reconnect: f_3,
      gate_name: f_4,
      conn_id: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("transfer_entity_control");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_main {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_main", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_reconnect {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_reconnect", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gate_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// KickOffClient
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KickOffClient {
  pub conn_id: Option<String>,
}

impl KickOffClient {
  pub fn new<F1>(conn_id: F1) -> KickOffClient where F1: Into<Option<String>> {
    KickOffClient {
      conn_id: conn_id.into(),
    }
  }
}

impl TSerializable for KickOffClient {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KickOffClient> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KickOffClient {
      conn_id: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("kick_off_client");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientDisconnnect
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientDisconnnect {
  pub conn_id: Option<String>,
}

impl ClientDisconnnect {
  pub fn new<F1>(conn_id: F1) -> ClientDisconnnect where F1: Into<Option<String>> {
    ClientDisconnnect {
      conn_id: conn_id.into(),
    }
  }
}

impl TSerializable for ClientDisconnnect {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientDisconnnect> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientDisconnnect {
      conn_id: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_disconnnect");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientCallRpc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientCallRpc {
  pub conn_id: Option<String>,
  pub entity_id: Option<String>,
  pub msg_cb_id: Option<i64>,
  pub message: Option<common::Msg>,
}

impl ClientCallRpc {
  pub fn new<F1, F2, F3, F4>(conn_id: F1, entity_id: F2, msg_cb_id: F3, message: F4) -> ClientCallRpc where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<common::Msg>> {
    ClientCallRpc {
      conn_id: conn_id.into(),
      entity_id: entity_id.into(),
      msg_cb_id: msg_cb_id.into(),
      message: message.into(),
    }
  }
}

impl TSerializable for ClientCallRpc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientCallRpc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<common::Msg> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = common::Msg::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientCallRpc {
      conn_id: f_1,
      entity_id: f_2,
      msg_cb_id: f_3,
      message: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_call_rpc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.msg_cb_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("msg_cb_id", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientCallRsp
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientCallRsp {
  pub rsp: Option<common::RpcRsp>,
}

impl ClientCallRsp {
  pub fn new<F1>(rsp: F1) -> ClientCallRsp where F1: Into<Option<common::RpcRsp>> {
    ClientCallRsp {
      rsp: rsp.into(),
    }
  }
}

impl TSerializable for ClientCallRsp {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientCallRsp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::RpcRsp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::RpcRsp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientCallRsp {
      rsp: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_call_rsp");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.rsp {
      o_prot.write_field_begin(&TFieldIdentifier::new("rsp", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientCallErr
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientCallErr {
  pub err: Option<common::RpcErr>,
}

impl ClientCallErr {
  pub fn new<F1>(err: F1) -> ClientCallErr where F1: Into<Option<common::RpcErr>> {
    ClientCallErr {
      err: err.into(),
    }
  }
}

impl TSerializable for ClientCallErr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientCallErr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::RpcErr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::RpcErr::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientCallErr {
      err: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_call_err");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.err {
      o_prot.write_field_begin(&TFieldIdentifier::new("err", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClientCallNtf
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientCallNtf {
  pub entity_id: Option<String>,
  pub message: Option<common::Msg>,
}

impl ClientCallNtf {
  pub fn new<F1, F2>(entity_id: F1, message: F2) -> ClientCallNtf where F1: Into<Option<String>>, F2: Into<Option<common::Msg>> {
    ClientCallNtf {
      entity_id: entity_id.into(),
      message: message.into(),
    }
  }
}

impl TSerializable for ClientCallNtf {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientCallNtf> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<common::Msg> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = common::Msg::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClientCallNtf {
      entity_id: f_1,
      message: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("client_call_ntf");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// QueryServiceEntity
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryServiceEntity {
  pub service_name: Option<String>,
}

impl QueryServiceEntity {
  pub fn new<F1>(service_name: F1) -> QueryServiceEntity where F1: Into<Option<String>> {
    QueryServiceEntity {
      service_name: service_name.into(),
    }
  }
}

impl TSerializable for QueryServiceEntity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryServiceEntity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = QueryServiceEntity {
      service_name: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("query_service_entity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.service_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("service_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CreateServiceEntity
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CreateServiceEntity {
  pub is_migrate: Option<bool>,
  pub service_name: Option<String>,
  pub entity_id: Option<String>,
  pub entity_type: Option<String>,
  pub argvs: Option<Vec<u8>>,
}

impl CreateServiceEntity {
  pub fn new<F1, F2, F3, F4, F5>(is_migrate: F1, service_name: F2, entity_id: F3, entity_type: F4, argvs: F5) -> CreateServiceEntity where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<Vec<u8>>> {
    CreateServiceEntity {
      is_migrate: is_migrate.into(),
      service_name: service_name.into(),
      entity_id: entity_id.into(),
      entity_type: entity_type.into(),
      argvs: argvs.into(),
    }
  }
}

impl TSerializable for CreateServiceEntity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CreateServiceEntity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CreateServiceEntity {
      is_migrate: f_1,
      service_name: f_2,
      entity_id: f_3,
      entity_type: f_4,
      argvs: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_service_entity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_migrate {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_migrate", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("service_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_type", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.argvs {
      o_prot.write_field_begin(&TFieldIdentifier::new("argvs", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubForwardClientRequestService
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubForwardClientRequestService {
  pub service_name: Option<String>,
  pub gate_name: Option<String>,
  pub gate_host: Option<String>,
  pub conn_id: Option<String>,
}

impl HubForwardClientRequestService {
  pub fn new<F1, F2, F3, F4>(service_name: F1, gate_name: F2, gate_host: F3, conn_id: F4) -> HubForwardClientRequestService where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>> {
    HubForwardClientRequestService {
      service_name: service_name.into(),
      gate_name: gate_name.into(),
      gate_host: gate_host.into(),
      conn_id: conn_id.into(),
    }
  }
}

impl TSerializable for HubForwardClientRequestService {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubForwardClientRequestService> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubForwardClientRequestService {
      service_name: f_1,
      gate_name: f_2,
      gate_host: f_3,
      conn_id: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_forward_client_request_service");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.service_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("service_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gate_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gate_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("gate_host", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("conn_id", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubRpc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubRpc {
  pub entity_id: Option<String>,
  pub msg_cb_id: Option<i64>,
  pub message: Option<common::Msg>,
}

impl HubCallHubRpc {
  pub fn new<F1, F2, F3>(entity_id: F1, msg_cb_id: F2, message: F3) -> HubCallHubRpc where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<common::Msg>> {
    HubCallHubRpc {
      entity_id: entity_id.into(),
      msg_cb_id: msg_cb_id.into(),
      message: message.into(),
    }
  }
}

impl TSerializable for HubCallHubRpc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubRpc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<common::Msg> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = common::Msg::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubRpc {
      entity_id: f_1,
      msg_cb_id: f_2,
      message: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_rpc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.msg_cb_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("msg_cb_id", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubRsp
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubRsp {
  pub rsp: Option<common::RpcRsp>,
}

impl HubCallHubRsp {
  pub fn new<F1>(rsp: F1) -> HubCallHubRsp where F1: Into<Option<common::RpcRsp>> {
    HubCallHubRsp {
      rsp: rsp.into(),
    }
  }
}

impl TSerializable for HubCallHubRsp {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubRsp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::RpcRsp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::RpcRsp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubRsp {
      rsp: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_rsp");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.rsp {
      o_prot.write_field_begin(&TFieldIdentifier::new("rsp", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubErr
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubErr {
  pub err: Option<common::RpcErr>,
}

impl HubCallHubErr {
  pub fn new<F1>(err: F1) -> HubCallHubErr where F1: Into<Option<common::RpcErr>> {
    HubCallHubErr {
      err: err.into(),
    }
  }
}

impl TSerializable for HubCallHubErr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubErr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::RpcErr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::RpcErr::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubErr {
      err: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_err");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.err {
      o_prot.write_field_begin(&TFieldIdentifier::new("err", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubNtf
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubNtf {
  pub entity_id: Option<String>,
  pub message: Option<common::Msg>,
}

impl HubCallHubNtf {
  pub fn new<F1, F2>(entity_id: F1, message: F2) -> HubCallHubNtf where F1: Into<Option<String>>, F2: Into<Option<common::Msg>> {
    HubCallHubNtf {
      entity_id: entity_id.into(),
      message: message.into(),
    }
  }
}

impl TSerializable for HubCallHubNtf {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubNtf> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<common::Msg> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = common::Msg::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubNtf {
      entity_id: f_1,
      message: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_ntf");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubWaitMigrateEntity
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubWaitMigrateEntity {
  pub entity_id: Option<String>,
}

impl HubCallHubWaitMigrateEntity {
  pub fn new<F1>(entity_id: F1) -> HubCallHubWaitMigrateEntity where F1: Into<Option<String>> {
    HubCallHubWaitMigrateEntity {
      entity_id: entity_id.into(),
    }
  }
}

impl TSerializable for HubCallHubWaitMigrateEntity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubWaitMigrateEntity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubWaitMigrateEntity {
      entity_id: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_wait_migrate_entity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubMigrateEntity
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubMigrateEntity {
  pub service_name: Option<String>,
  pub entity_id: Option<String>,
  pub entity_type: Option<String>,
  pub main_gate_name: Option<String>,
  pub main_conn_id: Option<String>,
  pub gates: Option<Vec<String>>,
  pub hubs: Option<Vec<String>>,
  pub argvs: Option<Vec<u8>>,
}

impl HubCallHubMigrateEntity {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(service_name: F1, entity_id: F2, entity_type: F3, main_gate_name: F4, main_conn_id: F5, gates: F6, hubs: F7, argvs: F8) -> HubCallHubMigrateEntity where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<Vec<String>>>, F8: Into<Option<Vec<u8>>> {
    HubCallHubMigrateEntity {
      service_name: service_name.into(),
      entity_id: entity_id.into(),
      entity_type: entity_type.into(),
      main_gate_name: main_gate_name.into(),
      main_conn_id: main_conn_id.into(),
      gates: gates.into(),
      hubs: hubs.into(),
      argvs: argvs.into(),
    }
  }
}

impl TSerializable for HubCallHubMigrateEntity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubMigrateEntity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<Vec<String>> = Some(Vec::new());
    let mut f_7: Option<Vec<String>> = Some(Vec::new());
    let mut f_8: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_string()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bytes()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubMigrateEntity {
      service_name: f_1,
      entity_id: f_2,
      entity_type: f_3,
      main_gate_name: f_4,
      main_conn_id: f_5,
      gates: f_6,
      hubs: f_7,
      argvs: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_migrate_entity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.service_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("service_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_type", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.main_gate_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("main_gate_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.main_conn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("main_conn_id", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.gates {
      o_prot.write_field_begin(&TFieldIdentifier::new("gates", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hubs {
      o_prot.write_field_begin(&TFieldIdentifier::new("hubs", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.argvs {
      o_prot.write_field_begin(&TFieldIdentifier::new("argvs", TType::String, 8))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubCreateMigrateEntity
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubCreateMigrateEntity {
  pub hub_name: Option<String>,
  pub entity_id: Option<String>,
}

impl HubCallHubCreateMigrateEntity {
  pub fn new<F1, F2>(hub_name: F1, entity_id: F2) -> HubCallHubCreateMigrateEntity where F1: Into<Option<String>>, F2: Into<Option<String>> {
    HubCallHubCreateMigrateEntity {
      hub_name: hub_name.into(),
      entity_id: entity_id.into(),
    }
  }
}

impl TSerializable for HubCallHubCreateMigrateEntity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubCreateMigrateEntity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubCreateMigrateEntity {
      hub_name: f_1,
      entity_id: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_create_migrate_entity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hub_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("hub_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubCallHubMigrateEntityComplete
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HubCallHubMigrateEntityComplete {
  pub hub_name: Option<String>,
  pub entity_id: Option<String>,
}

impl HubCallHubMigrateEntityComplete {
  pub fn new<F1, F2>(hub_name: F1, entity_id: F2) -> HubCallHubMigrateEntityComplete where F1: Into<Option<String>>, F2: Into<Option<String>> {
    HubCallHubMigrateEntityComplete {
      hub_name: hub_name.into(),
      entity_id: entity_id.into(),
    }
  }
}

impl TSerializable for HubCallHubMigrateEntityComplete {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubCallHubMigrateEntityComplete> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HubCallHubMigrateEntityComplete {
      hub_name: f_1,
      entity_id: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_call_hub_migrate_entity_complete");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hub_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("hub_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("entity_id", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HubService
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum HubService {
  ClientRequestLogin(ClientRequestLogin),
  ClientRequestReconnect(ClientRequestReconnect),
  TransferMsgEnd(TransferMsgEnd),
  TransferEntityControl(TransferEntityControl),
  KickOffClient(KickOffClient),
  ClientDisconnnect(ClientDisconnnect),
  ClientRequestService(ClientRequestService),
  ClientCallRpc(ClientCallRpc),
  ClientCallRsp(ClientCallRsp),
  ClientCallErr(ClientCallErr),
  ClientCallNtf(ClientCallNtf),
  RegServer(common::RegServer),
  RegServerCallback(common::RegServerCallback),
  QueryEntity(QueryServiceEntity),
  CreateServiceEntity(CreateServiceEntity),
  HubForwardClientRequestService(HubForwardClientRequestService),
  HubCallRpc(HubCallHubRpc),
  HubCallRsp(HubCallHubRsp),
  HubCallErr(HubCallHubErr),
  HubCallNtf(HubCallHubNtf),
  WaitMigrateEntity(HubCallHubWaitMigrateEntity),
  MigrateEntity(HubCallHubMigrateEntity),
  CreateMigrateEntity(HubCallHubCreateMigrateEntity),
  MigrateEntityComplete(HubCallHubMigrateEntityComplete),
}

impl TSerializable for HubService {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HubService> {
    let mut ret: Option<HubService> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ClientRequestLogin::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientRequestLogin(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = ClientRequestReconnect::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientRequestReconnect(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TransferMsgEnd::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::TransferMsgEnd(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = TransferEntityControl::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::TransferEntityControl(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = KickOffClient::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::KickOffClient(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = ClientDisconnnect::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientDisconnnect(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = ClientRequestService::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientRequestService(val));
          }
          received_field_count += 1;
        },
        8 => {
          let val = ClientCallRpc::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientCallRpc(val));
          }
          received_field_count += 1;
        },
        9 => {
          let val = ClientCallRsp::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientCallRsp(val));
          }
          received_field_count += 1;
        },
        10 => {
          let val = ClientCallErr::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientCallErr(val));
          }
          received_field_count += 1;
        },
        11 => {
          let val = ClientCallNtf::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::ClientCallNtf(val));
          }
          received_field_count += 1;
        },
        12 => {
          let val = common::RegServer::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::RegServer(val));
          }
          received_field_count += 1;
        },
        13 => {
          let val = common::RegServerCallback::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::RegServerCallback(val));
          }
          received_field_count += 1;
        },
        14 => {
          let val = QueryServiceEntity::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::QueryEntity(val));
          }
          received_field_count += 1;
        },
        15 => {
          let val = CreateServiceEntity::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::CreateServiceEntity(val));
          }
          received_field_count += 1;
        },
        16 => {
          let val = HubForwardClientRequestService::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::HubForwardClientRequestService(val));
          }
          received_field_count += 1;
        },
        17 => {
          let val = HubCallHubRpc::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::HubCallRpc(val));
          }
          received_field_count += 1;
        },
        18 => {
          let val = HubCallHubRsp::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::HubCallRsp(val));
          }
          received_field_count += 1;
        },
        19 => {
          let val = HubCallHubErr::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::HubCallErr(val));
          }
          received_field_count += 1;
        },
        20 => {
          let val = HubCallHubNtf::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::HubCallNtf(val));
          }
          received_field_count += 1;
        },
        21 => {
          let val = HubCallHubWaitMigrateEntity::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::WaitMigrateEntity(val));
          }
          received_field_count += 1;
        },
        22 => {
          let val = HubCallHubMigrateEntity::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::MigrateEntity(val));
          }
          received_field_count += 1;
        },
        23 => {
          let val = HubCallHubCreateMigrateEntity::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::CreateMigrateEntity(val));
          }
          received_field_count += 1;
        },
        24 => {
          let val = HubCallHubMigrateEntityComplete::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(HubService::MigrateEntityComplete(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote HubService"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote HubService"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("hub_service");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      HubService::ClientRequestLogin(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_request_login", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::ClientRequestReconnect(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_request_reconnect", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::TransferMsgEnd(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("transfer_msg_end", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::TransferEntityControl(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("transfer_entity_control", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::KickOffClient(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("kick_off_client", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::ClientDisconnnect(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_disconnnect", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::ClientRequestService(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_request_service", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::ClientCallRpc(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_call_rpc", TType::Struct, 8))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::ClientCallRsp(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_call_rsp", TType::Struct, 9))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::ClientCallErr(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_call_err", TType::Struct, 10))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::ClientCallNtf(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("client_call_ntf", TType::Struct, 11))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::RegServer(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("reg_server", TType::Struct, 12))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::RegServerCallback(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("reg_server_callback", TType::Struct, 13))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::QueryEntity(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("query_entity", TType::Struct, 14))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::CreateServiceEntity(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("create_service_entity", TType::Struct, 15))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::HubForwardClientRequestService(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("hub_forward_client_request_service", TType::Struct, 16))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::HubCallRpc(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("hub_call_rpc", TType::Struct, 17))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::HubCallRsp(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("hub_call_rsp", TType::Struct, 18))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::HubCallErr(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("hub_call_err", TType::Struct, 19))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::HubCallNtf(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("hub_call_ntf", TType::Struct, 20))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::WaitMigrateEntity(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("wait_migrate_entity", TType::Struct, 21))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::MigrateEntity(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("migrate_entity", TType::Struct, 22))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::CreateMigrateEntity(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("create_migrate_entity", TType::Struct, 23))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      HubService::MigrateEntityComplete(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("migrate_entity_complete", TType::Struct, 24))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckGetGuid
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckGetGuid {
  pub callback_id: Option<String>,
  pub guid: Option<i64>,
}

impl AckGetGuid {
  pub fn new<F1, F2>(callback_id: F1, guid: F2) -> AckGetGuid where F1: Into<Option<String>>, F2: Into<Option<i64>> {
    AckGetGuid {
      callback_id: callback_id.into(),
      guid: guid.into(),
    }
  }
}

impl TSerializable for AckGetGuid {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckGetGuid> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckGetGuid {
      callback_id: f_1,
      guid: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_get_guid");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckCreateObject
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckCreateObject {
  pub callback_id: Option<String>,
  pub result: Option<bool>,
}

impl AckCreateObject {
  pub fn new<F1, F2>(callback_id: F1, result: F2) -> AckCreateObject where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    AckCreateObject {
      callback_id: callback_id.into(),
      result: result.into(),
    }
  }
}

impl TSerializable for AckCreateObject {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckCreateObject> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckCreateObject {
      callback_id: f_1,
      result: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_create_object");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckUpdataObject
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckUpdataObject {
  pub callback_id: Option<String>,
  pub result: Option<bool>,
}

impl AckUpdataObject {
  pub fn new<F1, F2>(callback_id: F1, result: F2) -> AckUpdataObject where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    AckUpdataObject {
      callback_id: callback_id.into(),
      result: result.into(),
    }
  }
}

impl TSerializable for AckUpdataObject {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckUpdataObject> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckUpdataObject {
      callback_id: f_1,
      result: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_updata_object");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckFindAndModify
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckFindAndModify {
  pub callback_id: Option<String>,
  pub object_info: Option<Vec<u8>>,
}

impl AckFindAndModify {
  pub fn new<F1, F2>(callback_id: F1, object_info: F2) -> AckFindAndModify where F1: Into<Option<String>>, F2: Into<Option<Vec<u8>>> {
    AckFindAndModify {
      callback_id: callback_id.into(),
      object_info: object_info.into(),
    }
  }
}

impl TSerializable for AckFindAndModify {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckFindAndModify> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckFindAndModify {
      callback_id: f_1,
      object_info: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_find_and_modify");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.object_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("object_info", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckRemoveObject
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckRemoveObject {
  pub callback_id: Option<String>,
  pub result: Option<bool>,
}

impl AckRemoveObject {
  pub fn new<F1, F2>(callback_id: F1, result: F2) -> AckRemoveObject where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    AckRemoveObject {
      callback_id: callback_id.into(),
      result: result.into(),
    }
  }
}

impl TSerializable for AckRemoveObject {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckRemoveObject> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckRemoveObject {
      callback_id: f_1,
      result: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_remove_object");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckGetObjectCount
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckGetObjectCount {
  pub callback_id: Option<String>,
  pub count: Option<i32>,
}

impl AckGetObjectCount {
  pub fn new<F1, F2>(callback_id: F1, count: F2) -> AckGetObjectCount where F1: Into<Option<String>>, F2: Into<Option<i32>> {
    AckGetObjectCount {
      callback_id: callback_id.into(),
      count: count.into(),
    }
  }
}

impl TSerializable for AckGetObjectCount {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckGetObjectCount> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckGetObjectCount {
      callback_id: f_1,
      count: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_get_object_count");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.count {
      o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckGetObjectInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckGetObjectInfo {
  pub callback_id: Option<String>,
  pub object_info: Option<Vec<u8>>,
}

impl AckGetObjectInfo {
  pub fn new<F1, F2>(callback_id: F1, object_info: F2) -> AckGetObjectInfo where F1: Into<Option<String>>, F2: Into<Option<Vec<u8>>> {
    AckGetObjectInfo {
      callback_id: callback_id.into(),
      object_info: object_info.into(),
    }
  }
}

impl TSerializable for AckGetObjectInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckGetObjectInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckGetObjectInfo {
      callback_id: f_1,
      object_info: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_get_object_info");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.object_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("object_info", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AckGetObjectInfoEnd
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AckGetObjectInfoEnd {
  pub callback_id: Option<String>,
}

impl AckGetObjectInfoEnd {
  pub fn new<F1>(callback_id: F1) -> AckGetObjectInfoEnd where F1: Into<Option<String>> {
    AckGetObjectInfoEnd {
      callback_id: callback_id.into(),
    }
  }
}

impl TSerializable for AckGetObjectInfoEnd {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AckGetObjectInfoEnd> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AckGetObjectInfoEnd {
      callback_id: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ack_get_object_info_end");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DbCallback
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum DbCallback {
  GetGuid(AckGetGuid),
  CreateObject(AckCreateObject),
  UpdataObject(AckUpdataObject),
  FindAndModify(AckFindAndModify),
  RemoveObject(AckRemoveObject),
  GetObjectCount(AckGetObjectCount),
  GetObjectInfo(AckGetObjectInfo),
  GetObjectInfoEnd(AckGetObjectInfoEnd),
}

impl TSerializable for DbCallback {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DbCallback> {
    let mut ret: Option<DbCallback> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AckGetGuid::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::GetGuid(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = AckCreateObject::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::CreateObject(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = AckUpdataObject::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::UpdataObject(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = AckFindAndModify::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::FindAndModify(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = AckRemoveObject::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::RemoveObject(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = AckGetObjectCount::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::GetObjectCount(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = AckGetObjectInfo::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::GetObjectInfo(val));
          }
          received_field_count += 1;
        },
        8 => {
          let val = AckGetObjectInfoEnd::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbCallback::GetObjectInfoEnd(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote DbCallback"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote DbCallback"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_callback");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      DbCallback::GetGuid(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("get_guid", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbCallback::CreateObject(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("create_object", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbCallback::UpdataObject(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("updata_object", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbCallback::FindAndModify(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("find_and_modify", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbCallback::RemoveObject(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("remove_object", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbCallback::GetObjectCount(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("get_object_count", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbCallback::GetObjectInfo(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("get_object_info", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbCallback::GetObjectInfoEnd(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("get_object_info_end", TType::Struct, 8))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

