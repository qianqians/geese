// Autogenerated by Thrift Compiler (0.18.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

//
// RegHubEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RegHubEvent {
  pub hub_name: Option<String>,
}

impl RegHubEvent {
  pub fn new<F1>(hub_name: F1) -> RegHubEvent where F1: Into<Option<String>> {
    RegHubEvent {
      hub_name: hub_name.into(),
    }
  }
}

impl TSerializable for RegHubEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RegHubEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RegHubEvent {
      hub_name: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("reg_hub_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hub_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("hub_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetGuidEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetGuidEvent {
  pub db: Option<String>,
  pub collection: Option<String>,
  pub callback_id: Option<String>,
}

impl GetGuidEvent {
  pub fn new<F1, F2, F3>(db: F1, collection: F2, callback_id: F3) -> GetGuidEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    GetGuidEvent {
      db: db.into(),
      collection: collection.into(),
      callback_id: callback_id.into(),
    }
  }
}

impl TSerializable for GetGuidEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetGuidEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetGuidEvent {
      db: f_1,
      collection: f_2,
      callback_id: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_guid_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CreateObjectEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CreateObjectEvent {
  pub db: Option<String>,
  pub collection: Option<String>,
  pub callback_id: Option<String>,
  pub object_info: Option<Vec<u8>>,
}

impl CreateObjectEvent {
  pub fn new<F1, F2, F3, F4>(db: F1, collection: F2, callback_id: F3, object_info: F4) -> CreateObjectEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<u8>>> {
    CreateObjectEvent {
      db: db.into(),
      collection: collection.into(),
      callback_id: callback_id.into(),
      object_info: object_info.into(),
    }
  }
}

impl TSerializable for CreateObjectEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CreateObjectEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CreateObjectEvent {
      db: f_1,
      collection: f_2,
      callback_id: f_3,
      object_info: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_object_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.object_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("object_info", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpdateObjectEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpdateObjectEvent {
  pub db: Option<String>,
  pub collection: Option<String>,
  pub callback_id: Option<String>,
  pub query_info: Option<Vec<u8>>,
  pub updata_info: Option<Vec<u8>>,
  pub _upsert: Option<bool>,
}

impl UpdateObjectEvent {
  pub fn new<F1, F2, F3, F4, F5, F6>(db: F1, collection: F2, callback_id: F3, query_info: F4, updata_info: F5, _upsert: F6) -> UpdateObjectEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<bool>> {
    UpdateObjectEvent {
      db: db.into(),
      collection: collection.into(),
      callback_id: callback_id.into(),
      query_info: query_info.into(),
      updata_info: updata_info.into(),
      _upsert: _upsert.into(),
    }
  }
}

impl TSerializable for UpdateObjectEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpdateObjectEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpdateObjectEvent {
      db: f_1,
      collection: f_2,
      callback_id: f_3,
      query_info: f_4,
      updata_info: f_5,
      _upsert: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_object_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_info", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.updata_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("updata_info", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self._upsert {
      o_prot.write_field_begin(&TFieldIdentifier::new("_upsert", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FindAndModifyEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FindAndModifyEvent {
  pub db: Option<String>,
  pub collection: Option<String>,
  pub callback_id: Option<String>,
  pub query_info: Option<Vec<u8>>,
  pub updata_info: Option<Vec<u8>>,
  pub _new: Option<bool>,
  pub _upsert: Option<bool>,
}

impl FindAndModifyEvent {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(db: F1, collection: F2, callback_id: F3, query_info: F4, updata_info: F5, _new: F6, _upsert: F7) -> FindAndModifyEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<bool>>, F7: Into<Option<bool>> {
    FindAndModifyEvent {
      db: db.into(),
      collection: collection.into(),
      callback_id: callback_id.into(),
      query_info: query_info.into(),
      updata_info: updata_info.into(),
      _new: _new.into(),
      _upsert: _upsert.into(),
    }
  }
}

impl TSerializable for FindAndModifyEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FindAndModifyEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FindAndModifyEvent {
      db: f_1,
      collection: f_2,
      callback_id: f_3,
      query_info: f_4,
      updata_info: f_5,
      _new: f_6,
      _upsert: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("find_and_modify_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_info", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.updata_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("updata_info", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self._new {
      o_prot.write_field_begin(&TFieldIdentifier::new("_new", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self._upsert {
      o_prot.write_field_begin(&TFieldIdentifier::new("_upsert", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RemoveObjectEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RemoveObjectEvent {
  pub db: Option<String>,
  pub collection: Option<String>,
  pub callback_id: Option<String>,
  pub query_info: Option<Vec<u8>>,
}

impl RemoveObjectEvent {
  pub fn new<F1, F2, F3, F4>(db: F1, collection: F2, callback_id: F3, query_info: F4) -> RemoveObjectEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<u8>>> {
    RemoveObjectEvent {
      db: db.into(),
      collection: collection.into(),
      callback_id: callback_id.into(),
      query_info: query_info.into(),
    }
  }
}

impl TSerializable for RemoveObjectEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RemoveObjectEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RemoveObjectEvent {
      db: f_1,
      collection: f_2,
      callback_id: f_3,
      query_info: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("remove_object_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_info", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetObjectInfoEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetObjectInfoEvent {
  pub db: Option<String>,
  pub collection: Option<String>,
  pub callback_id: Option<String>,
  pub query_info: Option<Vec<u8>>,
  pub skip: Option<i32>,
  pub limit: Option<i32>,
  pub sort: Option<String>,
  pub ascending: Option<bool>,
}

impl GetObjectInfoEvent {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(db: F1, collection: F2, callback_id: F3, query_info: F4, skip: F5, limit: F6, sort: F7, ascending: F8) -> GetObjectInfoEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<String>>, F8: Into<Option<bool>> {
    GetObjectInfoEvent {
      db: db.into(),
      collection: collection.into(),
      callback_id: callback_id.into(),
      query_info: query_info.into(),
      skip: skip.into(),
      limit: limit.into(),
      sort: sort.into(),
      ascending: ascending.into(),
    }
  }
}

impl TSerializable for GetObjectInfoEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetObjectInfoEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetObjectInfoEvent {
      db: f_1,
      collection: f_2,
      callback_id: f_3,
      query_info: f_4,
      skip: f_5,
      limit: f_6,
      sort: f_7,
      ascending: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_object_info_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_info", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sort {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ascending {
      o_prot.write_field_begin(&TFieldIdentifier::new("ascending", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetObjectCountEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetObjectCountEvent {
  pub db: Option<String>,
  pub collection: Option<String>,
  pub callback_id: Option<String>,
  pub query_info: Option<Vec<u8>>,
}

impl GetObjectCountEvent {
  pub fn new<F1, F2, F3, F4>(db: F1, collection: F2, callback_id: F3, query_info: F4) -> GetObjectCountEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<u8>>> {
    GetObjectCountEvent {
      db: db.into(),
      collection: collection.into(),
      callback_id: callback_id.into(),
      query_info: query_info.into(),
    }
  }
}

impl TSerializable for GetObjectCountEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetObjectCountEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetObjectCountEvent {
      db: f_1,
      collection: f_2,
      callback_id: f_3,
      query_info: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_object_count_event");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.callback_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("callback_id", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_info", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DbEvent
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum DbEvent {
  RegHub(RegHubEvent),
  GetGuid(GetGuidEvent),
  CreateObject(CreateObjectEvent),
  UpdateObject(UpdateObjectEvent),
  FindAndModify(FindAndModifyEvent),
  RemoveObject(RemoveObjectEvent),
  GetObjectInfo(GetObjectInfoEvent),
  GetObjectCount(GetObjectCountEvent),
}

impl TSerializable for DbEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DbEvent> {
    let mut ret: Option<DbEvent> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = RegHubEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::RegHub(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = GetGuidEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::GetGuid(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = CreateObjectEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::CreateObject(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = UpdateObjectEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::UpdateObject(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = FindAndModifyEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::FindAndModify(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = RemoveObjectEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::RemoveObject(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = GetObjectInfoEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::GetObjectInfo(val));
          }
          received_field_count += 1;
        },
        8 => {
          let val = GetObjectCountEvent::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DbEvent::GetObjectCount(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote DbEvent"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote DbEvent"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_event");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      DbEvent::RegHub(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("reg_hub", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbEvent::GetGuid(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("get_guid", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbEvent::CreateObject(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("create_object", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbEvent::UpdateObject(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("update_object", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbEvent::FindAndModify(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("find_and_modify", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbEvent::RemoveObject(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("remove_object", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbEvent::GetObjectInfo(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("get_object_info", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DbEvent::GetObjectCount(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("get_object_count", TType::Struct, 8))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

